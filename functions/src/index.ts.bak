import * as functions from "firebase-functions";
import * as admin from "firebase-admin";
import axios from "axios";

admin.initializeApp();

// ScrapingBee API configuration
const SCRAPINGBEE_API_URL = "https://app.scrapingbee.com/api/v1/";

interface ScrapedResult {
    title: string;
    description: string;
    image: string;
    price?: string;
    currency?: string;
    priceSource?: string;
    error?: string;
    errorCode?: string;
    _debug?: any;
}

// Site-specific CSS selectors for element-based waiting
const WAIT_FOR_SELECTORS: Record<string, string> = {
    "adidas.": ".product-description,.product-row,.gl-product-card,.product-details",
    "zara.": ".product-detail,.product-card,[data-qa=\"product-price\"]",
    "nike.": ".product-info,.product-card,.css-b9fpep",
    "hm.": ".product-item,.product-detail,.pdp-content",
    "shein.": ".product-info,.goods-detail,.product-intro",
};

function getWaitForSelector(url: string): string | null {
    try {
        const hostname = new URL(url).hostname.toLowerCase();
        for (const [domain, selector] of Object.entries(WAIT_FOR_SELECTORS)) {
            if (hostname.includes(domain)) return selector;
        }
    } catch { }
    return null;
}

function isBlockPage(html: string): boolean {
    const lower = html.toLowerCase();

    // Text-based indicators
    const textIndicators = [
        "akamai",
        "access denied",
        "bot protection",
        "verify you are a human",
        "security check",
        "please enable javascript",
        "enable cookies",
        "reference id:",
        "cloudflare",
    ];

    if (textIndicators.some(i => lower.includes(i))) {
        return true;
    }

    // Image-based indicators (Akamai logo)
    if (html.includes("akamai.com") || html.includes("akamai-logo")) {
        return true;
    }

    return false;
}

function extractPrice(html: string): { price?: string, currency?: string, source: string } {
    console.log("extractPrice: Starting price extraction...");

    // 1. Meta Tags (og:price:amount, product:price:amount)
    let m = html.match(/<meta[^>]*property=["'](og:price:amount|product:price:amount)["'][^>]*content=["']([^"']+)["']/i);
    if (m && /\d/.test(m[2])) {
        console.log("extractPrice: Found meta tag price:", m[2]);
        let cur = "ILS";
        const curMatch = html.match(/<meta[^>]*property=["'](og:price:currency|product:price:currency)["'][^>]*content=["']([^"']+)["']/i);
        if (curMatch) cur = curMatch[2];
        return { price: m[2], currency: cur, source: "meta" };
    }

    // 2. JSON-LD (DEEP recursive search)
    console.log("extractPrice: Searching JSON-LD...");
    try {
        const regex = /<script[^>]*type=["']application\/ld\+json["'][^>]*>([\s\S]*?)<\/script>/gi;
        let match;
        const allPrices: Array<{ price: string, currency: string, confidence: number }> = [];

        while ((match = regex.exec(html)) !== null) {
            try {
                const jsonStr = match[1].trim();
                const parsed = JSON.parse(jsonStr);
                findPricesInObject(parsed, allPrices, 0);
            } catch (e) {
                // JSON parse error, skip this block
            }
        }

        if (allPrices.length > 0) {
            // Sort by confidence (highest first)
            allPrices.sort((a, b) => b.confidence - a.confidence);
            console.log("extractPrice: Found JSON-LD prices:", allPrices);
            return { price: allPrices[0].price, currency: allPrices[0].currency || "ILS", source: "jsonld" };
        }
    } catch (e) {
        console.log("extractPrice: JSON-LD extraction error:", e);
    }

    // 3. HTML class-based extraction (Adidas specific)
    console.log("extractPrice: Trying HTML class patterns...");
    const htmlPatterns = [
        // Adidas price classes
        /class="[^"]*price[^"]*"[^>]*>([^<]*₪[^<]*|\d{1,3}[,.]?\d*[^<]*₪)/gi,
        /class="[^"]*gl-price[^"]*"[^>]*>([^<]+)/gi,
        /data-testid="[^"]*price[^"]*"[^>]*>([^<]+)/gi,
        // Generic price patterns
        /<span[^>]*class="[^"]*sale-price[^"]*"[^>]*>([^<]+)/gi,
        /<div[^>]*class="[^"]*product-price[^"]*"[^>]*>([^<]+)/gi,
    ];

    for (const pattern of htmlPatterns) {
        pattern.lastIndex = 0;
        const htmlMatch = pattern.exec(html);
        if (htmlMatch) {
            const priceText = htmlMatch[1].replace(/<[^>]+>/g, '').trim();
            const numMatch = priceText.match(/(\d{1,3}(?:[,.]?\d{3})*(?:[.,]\d{1,2})?)/);
            if (numMatch) {
                console.log("extractPrice: Found HTML class price:", numMatch[1]);
                return { price: numMatch[1], currency: "ILS", source: "html" };
            }
        }
    }

    // 4. Regex fallback (Hebrew shekel patterns)
    console.log("extractPrice: Trying regex patterns...");
    const regexPatterns = [
        /₪\s*(\d{1,3}(?:[,.]?\d{3})*(?:[.,]\d{1,2})?)/g,
        /(\d{1,3}(?:[,.]?\d{3})*(?:[.,]\d{1,2})?)\s*₪/g,
        /(\d{1,3}(?:[,.]?\d{3})*(?:[.,]\d{1,2})?)\s*ש"ח/g,
        /ILS\s*(\d{1,3}(?:[,.]?\d{3})*(?:[.,]\d{1,2})?)/gi,
        /(\d{1,3}(?:[,.]?\d{3})*(?:[.,]\d{1,2})?)\s*ILS/gi,
    ];

    for (const pattern of regexPatterns) {
        pattern.lastIndex = 0;
        const regexMatch = pattern.exec(html);
        if (regexMatch) {
            const price = regexMatch[1];
            const priceNum = parseFloat(price.replace(/,/g, ''));
            if (priceNum > 0 && priceNum < 100000) {
                console.log("extractPrice: Found regex price:", price);
                return { price, currency: "ILS", source: "regex" };
            }
        }
    }

    console.log("extractPrice: No price found. HTML length:", html.length, "First 500 chars:", html.substring(0, 500));
    return { source: "none" };
}

/**
 * Recursively find prices in JSON-LD objects
 */
function findPricesInObject(obj: any, prices: Array<{ price: string, currency: string, confidence: number }>, depth: number): void {
    if (depth > 15 || !obj) return;

    if (Array.isArray(obj)) {
        for (const item of obj) {
            findPricesInObject(item, prices, depth + 1);
        }
        return;
    }

    if (typeof obj !== "object") return;

    const objType = obj["@type"];
    const isOffer = objType === "Offer" || objType === "AggregateOffer";
    const isProduct = objType === "Product";

    // Check for price fields
    if (obj.price !== undefined && obj.price !== null) {
        const priceVal = String(obj.price);
        if (/\d/.test(priceVal)) {
            prices.push({
                price: priceVal,
                currency: obj.priceCurrency || "ILS",
                confidence: isOffer ? 100 : isProduct ? 80 : 50
            });
        }
    }

    if (obj.lowPrice !== undefined) {
        prices.push({
            price: String(obj.lowPrice),
            currency: obj.priceCurrency || "ILS",
            confidence: isOffer ? 90 : 40
        });
    }

    if (obj.highPrice !== undefined) {
        prices.push({
            price: String(obj.highPrice),
            currency: obj.priceCurrency || "ILS",
            confidence: 30
        });
    }

    // Recurse into nested objects
    for (const key of Object.keys(obj)) {
        if (obj[key] && typeof obj[key] === "object") {
            findPricesInObject(obj[key], prices, depth + 1);
        }
    }
}

export const scrapeProductDetails = functions
    .runWith({
        timeoutSeconds: 60,
        memory: "512MB", // Reduced memory as we don't need browser emulation in node
    })
    .https.onCall(async (data, context): Promise<ScrapedResult> => {
        const url = data.url as string;
        if (!url) return { title: "", description: "", image: "", error: "No URL" };

        const apiKey = functions.config().scrapingbee?.api_key;
        if (!apiKey) return { title: "", description: "", image: "", error: "Config missing" };

        const cleanedUrl = cleanUrl(url);
        console.log(`Processing URL: ${cleanedUrl}`);

        // Tank Layer - Direct ScrapingBee via Axios
        const params: any = {
            api_key: apiKey,
            url: cleanedUrl,
            render_js: "true",
            premium_proxy: "true",
            stealth_proxy: "true",
            country_code: "il",
            wait: "5000", // Reduced wait to prevent timeouts
            wait_browser: "networkidle0",
            window_width: "1920",
            window_height: "1080",
            device: "desktop",
        };

        const selector = getWaitForSelector(cleanedUrl);
        if (selector) params.wait_for = selector;

        try {
            console.log("Calling ScrapingBee via Axios...");
            const response = await axios.get(SCRAPINGBEE_API_URL, {
                params: params,
                timeout: 55000, // 55s timeout (function is 60s)
            });

            const html = response.data;

            if (!html || html.length < 500) {
                console.warn("ScrapingBee returned empty/short content");
                return { title: "", description: "", image: "", error: "Empty content", errorCode: "SCRAPE_FAILED" };
            }

            if (isBlockPage(html)) {
                console.warn("BLOCKED by WAF");
                return { title: "", description: "", image: "", error: "Blocked by WAF", errorCode: "SCRAPE_FAILED_MANUAL_REQUIRED" };
            }

            console.log("HTML received, length:", html.length);

            const title = extractTitle(html);
            const description = extractDescription(html);
            const image = extractImage(html);
            const priceData = extractPrice(html);

            return {
                title,
                description,
                image,
                price: normalizePrice(priceData.price || "", priceData.currency),
                currency: priceData.currency,
                priceSource: priceData.source,
                _debug: {
                    htmlLength: html.length,
                    htmlSnippet: html.substring(0, 500),
                }
            };

        } catch (error) {
            console.error("ScrapingBee call failed:", error);
            // Check for timeout
            if (axios.isAxiosError(error) && (error.code === 'ECONNABORTED' || error.response?.status === 408)) {
                return { title: "", description: "", image: "", error: "Scraping timed out", errorCode: "SCRAPE_FAILED" };
            }
            return { title: "", description: "", image: "", error: "Scraping failed", errorCode: "SCRAPE_FAILED" };
        }
    });

export const ping = functions
    .https.onRequest((req, res) => {
        console.log("Ping triggered!");
        res.send("Pong!");
    });

export const debugNotificationCreate = functions
    .region("europe-west1")
    .firestore
    .document("notifications/{docId}")
    .onWrite((change, context) => {
        console.log("debugNotificationCreate triggered for:", context.params.docId);
        console.log("Change type:", change.after.exists ? "Created/Updated" : "Deleted");
    });

export const sendPushNotification = functions
    .region("europe-west1")
    .firestore
    .document("notifications/{notificationId}")
    .onCreate(async (snapshot, context) => {
        console.log("sendPushNotification triggered for ID:", snapshot.id);
        const notification = snapshot.data();
        const userId = notification.userId;

        if (!userId) {
            console.log("No userId in notification structure:", JSON.stringify(notification));
            return;
        }

        // Get the user's FCM tokens
        const userDoc = await admin.firestore().collection("users").doc(userId).get();
        const userData = userDoc.data();

        if (!userData || !userData.fcmTokens || userData.fcmTokens.length === 0) {
            console.log("No tokens for user", userId);
            return;
        }

        const tokens = userData.fcmTokens;

        // Prepare the message
        // Create a data object avoiding nested objects and ensuring all values are strings
        const dataPayload: Record<string, string> = {
            notificationId: snapshot.id,
            type: notification.type || "generic"
        };

        if (notification.data) {
            Object.entries(notification.data).forEach(([key, value]) => {
                if (typeof value === 'string') {
                    dataPayload[key] = value;
                } else {
                    dataPayload[key] = JSON.stringify(value);
                }
            });
        }

        const message: admin.messaging.MulticastMessage = {
            tokens: tokens,
            notification: {
                title: notification.title,
                body: notification.message || "New notification!",
            },
            data: dataPayload
        };

        try {
            const response = await admin.messaging().sendMulticast(message);
            console.log(`Sent ${response.successCount} notifications, failed: ${response.failureCount}`);

            // Cleanup invalid tokens
            if (response.failureCount > 0) {
                const failedTokens: string[] = [];
                response.responses.forEach((resp, idx) => {
                    if (!resp.success) {
                        const error = resp.error;
                        if (error?.code === 'messaging/invalid-registration-token' ||
                            error?.code === 'messaging/registration-token-not-registered') {
                            failedTokens.push(tokens[idx]);
                        }
                    }
                });

                if (failedTokens.length > 0) {
                    console.log("Removing invalid tokens:", failedTokens);
                    await admin.firestore().collection("users").doc(userId).update({
                        fcmTokens: admin.firestore.FieldValue.arrayRemove(...failedTokens)
                    });
                }
            }
        } catch (error) {
            console.error("Error sending notification:", error);
        }
    });

// ============================================================================
// HELPERS 
// ============================================================================

function cleanUrl(url: string): string {
    try {
        const u = new URL(url);
        ["utm_source", "utm_medium", "utm_campaign", "fbclid", "gclid"].forEach(p => u.searchParams.delete(p));
        return u.toString();
    } catch { return url; }
}

function extractTitle(html: string): string {
    const match = html.match(/<meta[^>]*property=["']og:title["'][^>]*content=["']([^"']+)["']/i) ||
        html.match(/<title[^>]*>([^<]+)<\/title>/i);
    return match ? match[1].trim() : "";
}

function extractDescription(html: string): string {
    const match = html.match(/<meta[^>]*property=["']og:description["'][^>]*content=["']([^"']+)["']/i) ||
        html.match(/<meta[^>]*name=["']description["'][^>]*content=["']([^"']+)["']/i);
    return match ? match[1] : "";
}

function extractImage(html: string): string {
    const match = html.match(/<meta[^>]*property=["']og:image["'][^>]*content=["']([^"']+)["']/i) ||
        html.match(/<meta[^>]*property=["']product:image["'][^>]*content=["']([^"']+)["']/i);
    return match ? match[1] : "";
}

/**
 * Normalize price format
 */
function normalizePrice(price: string, currency?: string): string {
    if (!price) return "";
    let cleanPrice = price.trim();

    if (/[₪$€£]/.test(cleanPrice)) {
        return cleanPrice;
    }

    const currencySymbols: Record<string, string> = {
        ILS: "₪", NIS: "₪", USD: "$", EUR: "€", GBP: "£",
    };

    const symbol = currency ? (currencySymbols[currency.toUpperCase()] || currency) : "₪";

    if (symbol === "₪") return `${cleanPrice}${symbol}`;
    return `${symbol}${cleanPrice}`;
}
